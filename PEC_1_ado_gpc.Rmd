---
title: "PEC 1. Análisis de datos ómicos."
author: "Guillermo Prol Castelo"
date: "11/2/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. El estudio (cuestiones a responder).

## I.1. Descripción del estudio.

## I.2. Librerías, directorios y funciones.

Comenzamos cargando todas las librerías que nos harán falta a lo largo del análisis.

```{r}
suppressMessages( library(Biobase) )
suppressMessages( library(GEOquery) )
suppressMessages( library(affy) )
suppressMessages( library(limma) )
suppressMessages( library(genefilter) )
suppressMessages( library(oligo) )
suppressMessages( library(arrayQualityMetrics) )
suppressMessages( library(ggplot2) )
suppressMessages( library(ggrepel) )
suppressMessages( library(gmodels) )
```

Para facilitar el estudio, trabajaremos en un directorio escogido por nosotros y cuya localización se asigna a la variable `workingDir`. Los datos se copiarán en un subdirectorio del anterior denominado `data`, que se almacenará en la variable `dataDir` y los resultados se almacenarán en un directorio `results`, cuyo nombre se almacenará en la variable `resultsDir`.

```{r}
workingDir <- getwd()
# Creamos los directorios de datos y resultados:
system("mkdir data")
system("mkdir results")
system("mkdir celfiles")
# Los asignamos a variables:
dataDir <-file.path(workingDir, "data")
resultsDir <- file.path(workingDir, "results")
celfilesDir <- file.path(workingDir,"celfiles")
# Seleccionamos el directorio de trabajo:
setwd(workingDir)
```

Cargamos las funciones necesarias para el análisis.

```{r}
# Declaramos el directorio de funciones:
functionsDir <- file.path(workingDir, "functions/")
# Cargamos la función plotPCA.R
source(file.path(functionsDir,"plotPCA.R"))
```


# II. Análisis.

## II.1. Obtención y lectura de los datos.




```{r}
gse <- getGEO("GSE3311", GSEMatrix = T, destdir = dataDir)
# Descargamos los datos ('raw data') en la carpeta de datos:
a <- getGEOSuppFiles("GSE3311",makeDirectory = F, baseDir = dataDir)
```

Podemos explorar su contenido:

```{r}
rownames(pData(phenoData(gse[[1]])))
colnames(pData(phenoData(gse[[1]])))
head(pData(phenoData(gse[[1]])))
```

Vemos que los tres primeros ficheros CEL corresponden al tratamiento control y los otros tres al tratamiento con etanol.

```{r}
# get info from gse
filedata <- pData(phenoData(gse[[1]]))
sampleNames <- rownames(filedata)
# get dataframe with .CEL files names:
file_to_txt <- data.frame(file_name=paste(sampleNames,'.CEL',sep=''),dataDir,filedata)
# Creamos una tabla con las muestras seleccionadas:
write.table(file_to_txt, 
            file=file.path(dataDir, "targets.txt"),
            sep="\t", 
            row.names=FALSE, 
            quote=FALSE)
```

```{r}
# Directory the .tar was saved to:
unpackDir <-  celfilesDir
# Decompress .tar file:
untar(file.path(dataDir, 'GSE3311_RAW.tar'), exdir = celfilesDir)
# Delete .tar file:
#file.remove(file.path(unpackDir, 'GSE18198_RAW.tar'))

# Decompress all .gz files in our directory:
for (i in list.files(unpackDir)) {
  gunzip(file.path(unpackDir, i))
}
```

Lectura de datos (los cargamos en R):
```{r}
#require(Biobase)
sampleInfo <-read.AnnotatedDataFrame(
  file.path(dataDir,"targets.txt"), 
  header = TRUE, row.names = 1) 
show(pData(sampleInfo))
```

El contenido del archivo targets se utiliza en la lectura de los datos y la creación del objeto rawData de la clase affybatch que contendrá las intensidades “crudas” de cada archivo .CEL.

```{r}
fileNames <- rownames(pData(sampleInfo))
rawData <- read.affybatch(filenames=file.path(celfilesDir,fileNames),
                          phenoData=sampleInfo)
show(rawData)
```


## II.2. Exploración, control de calidad y normalización.

```{r}
sampleNames <- filedata$title
plotPCA(exprs(rawData), labels=sampleNames, dataDesc="selected samples")
```

Distribución de señales:

```{r}
info <- data.frame(grupo=c(1,1,1,2,2,2))
#sampleNames <- filedata$title
hist(rawData, main="Signal distribution", col=info$grupo, lty=1:ncol(info))
legend (x="topright", 
        legend=sampleNames,#c(rep('Control',3),rep('Ethanol',3)) , 
        col=info$grupo, lty=1:ncol(info)
        )
```


Boxplot:

```{r}
colores <- c(rep("yellow", 3), rep("green", 3))
boxplot(rawData, cex.axis=0.6, col=colores, las=2, 
        names=c(rep('Control',3),rep('Ethanol',3)),
        main="Signal distribution for diets")
```

```{r}
#heatmap:
manDist <-  dist(t(exprs(rawData))) 
heatmap (as.matrix(manDist),  col=heat.colors(16),
         labRow = sampleNames, labCol = sampleNames) 
```

```{r}
## ----plotDendro
clust.euclid.average <- hclust(dist(t(exprs(rawData))),method="average")
plot(clust.euclid.average, labels=sampleNames, main="Hierarchical clustering of samples",  hang=-1)
```



### II.2.1. Control de calidad.

El paquete affyQCReport encapsula los análisis que pueden realizarse con el paquete simpleaffy, de forma que con una instrucción se pueden realizar todos los análisis y enviar la salida a un archivo.

```{r}
stopifnot(require(affyQCReport))
QCReport(rawData,file=file.path(resultsDir,"QCReport.pdf"))
```

El paquete affyPLM realiza un control de calidad basado en lo que se conoce como modelos a nivel de sonda o probe-level models, conocidos por sus siglas (PLM).

```{r}
stopifnot(require(affyPLM))
computePLM <- T
if(computePLM){
  Pset<- fitPLM(rawData)
  save(Pset, file=file.path(dataDir,"PLM.Rda"))
}else{
  load (file=file.path(dataDir,"PLM.Rda"))
}
```

Como resultado del ajuste PLM se pueden obtener dos gráficos, uno de expresiones relativas y otro con errores estandarizados (figura 27). Si los datos son de calidad, ambos gráficos deben ser centrados y relativamente simétricos. Cambios en esta situación sugieren problemas en los arrays que no los verifiquen.

```{r}
RLE(Pset, main = "Relative Log Expression", names=sampleNames, las=2, col=info$grupo+1, cex.axis=0.6,ylim=c(-5,5))
```

```{r}
NUSE(Pset, main = "Normalized Unscaled Standard Errors", las=2, names=sampleNames, col=info$grupo+1, cex.axis=0.6, ylim=c(0.5,1.5))
```


### II.2.2. Normalización y filtraje.

El procesado mediante RMA implica un proceso en tres etapas:

- Corrección de fondo (el RMA hace precisamente esto).

- Normalización para hacer los valores de los arrays comparables.

- Resumen (sumarización) de las diversas sondas asociadas a cada grupo de sondas para dar un único valor.

```{r}
stopifnot(require(affy))
normalize <- T
if(normalize){
  eset_rma <- affy::rma(rawData)    
  save(eset_rma, file=file.path(dataDir,"normalized.Rda"))
}else{
  load (file=file.path(dataDir,"normalized.Rda"))
}
```

Un boxplot de los valores normalizados sugiere que los valores ya están en una escala en donde se pueden comparar.


```{r}
boxplot(eset_rma,main="RMA", names=sampleNames, cex.axis=0.7, col=info$grupo+1,las=2)
```

**Filtraje**:

El filtraje no específico permite eliminar los genes que varían poco entre condiciones o que deseamos quitar por otras razones, como por ejemplo que no disponemos de anotación para ellos. La función nsFilter permite eliminar los genes que, o bien varían poco, o bien no se dispone de anotación para ellos.

Si al filtrar deseamos usar las anotaciones, o la falta de ellas, como criterio de filtraje, debemos disponer del correspondiente paquete de anotaciones.

En nuestro caso, tenemos que instalar el paquete 'rae230a.db':
```{r cho = T, results = 'hide'}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("rae230a.db")
```


```{r}
filtered <- nsFilter(eset_rma, require.entrez=TRUE,
                     remove.dupEntrez=TRUE, var.func=IQR,
                     var.cutoff=0.5, var.filter=TRUE,
                     filterByQuantile=TRUE, feature.exclude="^AFFX")
class(filtered)
names(filtered)
dim(exprs(filtered$eset))
```

La función nsFilter devuelve los valores filtrados en un objeto expressionSet y un informe de los resultados del filtraje.

```{r}
class(filtered$eset)
print(filtered$filter.log)
eset_filtered <-filtered$eset
```

Podemos grabar el objeto eset_rma y los datos filtrados para su posterior uso.

```{r}
save(eset_rma, eset_filtered, file=file.path(resultsDir, "estrogen-normalized.Rda"))
```

Después del filtraje han quedado 5227 genes disponibles para analizar.


## II.3. Selección de genes diferencialmente expresados.

### II.3.1. Análisis basado en modelos lineales.

**Matriz de diseño**:

Manualmente:

Tomamos como modelo lineal el siguiente:
$$
Y_{ij}=\alpha_i + \epsilon_{ij}
$$

Donde $\alpha_i$ tiene en cuenta el tipo de tratamiento, es decir:
$$
\left\{\begin{matrix}
\alpha_1=(Control)\\ 
\alpha_2=(Ethanol)\\ 
\end{matrix}\right.
$$

Por tanto, la matriz de diseño es:
$$
\begin{pmatrix}
1 & 0 \\ 
1 & 0 \\ 
1 & 0 \\ 
0 & 1 \\ 
0 & 1 \\ 
0 & 1 \\ 
\end{pmatrix}
$$
La escribimos en forma de código:

```{r}
design.1<-matrix(
c(1,1,1,0,0,0,
  0,0,0,1,1,1),
nrow=6,
byrow=F)
colnames(design.1)<-c("Control", "Ethanol")
rownames(design.1) <-  c('Control_1','Control_2','Control_3','Ethanol_1','Ethanol_2','Ethanol_3')
print(design.1)
```


Computacionalmente, utilizando el paquete `limma`.
```{r}
if (!exists("eset_rma"))  load(file.path(dataDir, "normalized.rda"))
targets <- pData(eset_rma)
```

```{r}
lev<-factor(c('Control','Control','Control','Ethanol','Ethanol','Ethanol'), 
            levels=c('Control','Ethanol')
            )
design <-model.matrix(~0+lev)
colnames(design)<-levels(lev)
rownames(design) <-sampleNames
print(design)
```

**Contrastes**:

En este caso, nos interesa estudiar el efecto del etanol en la dieta de los ratones, es decir, la diferencia entre la dieta con etanol y la dieta control.

Lo podemos formular como:
$$
\beta=\alpha_2-\alpha_1 \rightarrow  efecto\; del \; etanol
$$
La matriz de contraste correspondiente es, simplemente:

$$
\bigl(\begin{smallmatrix}
1 & -1
\end{smallmatrix}\bigr)
$$
Esta se puede hallar también de forma computacional:

```{r}
cont.matrix <- makeContrasts (
  Diet = Ethanol - Control,
  levels=design
  )
cont.matrix
```


### II.3.2. Comparaciones múltiples.


### II.3.3. Anotación de resultados.


### II.3.4. Visualización de los perfiles de expresión.



# III. Resultados y discusión.














